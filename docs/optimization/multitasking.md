# 後端工程師為何需要理解多工?

因為後端工程師所建構的程式、都是為了服務大量的使用者而打造。
理解電腦多工的運作原理、你才能有效壓榨伺服器的資源、用更少的資源、提供更多服務能量。

# 什麼是多工 (Multitasking)

Multitasking 指的是、可以在同時間處理很多事情。

但是在電腦的領域裡、多工可以是真的多工、或是看起來多工。那麼它們的區別在什麼地方呢?

這裡有一個最基礎的理論、一顆 CPU、不管怎麼樣、它同時間只能處理一件事。
所以要達成真的多工、你的電腦裡必需要有一顆以上的 CPU (或是 CPU 核心)
這樣一來、你可以將不同的工作分配給不同的 CPU 去同時執行。

那麼看起來多工又是怎麼回事呢? 假設你只有一顆 CPU、理論上你沒有辦法同時處理很多件事情。
但由於 CPU 的運作速度非常的快、如果我們讓 CPU 在各項要處理的事務之間快速的來回的切換執行、由於切換的速度很快、對於人類看起來、它就像是在同時處理很多件事情。

舉個例子來説、即使在只有一顆 CPU 的電腦上，當你使用 GUI 的時候、你仍然可以開啓多個視窗同時做不同的事情。例如 A 視窗在播放影片、B 視窗在下載檔案。那麽它們真的是在同時進行工作嗎?
其實并不是、系統只是快速的在 A / B 視窗的工作之間切換、由於切換的速度很快，看起來 A 和 B 視窗就同時在工作了。

當然你有多顆 CPU 的時候系統仍然是會來回切換工作的，只是同時間能真的被執行的工作數量上升了。

# 先佔式多工 vs 協同式多工

這兩個名詞主要針對的是上面提到的「在要處理的事務之間快速切換的方式」。

先佔式多工、事務之間的切換有一個統一的總管負責。由它來分配每件事務可以佔用的時間。時間一到、它就會強制的把執行權限移交給下一個事務。

而協同式多工、則是事務本身自行決定什麼時候移交執行權限給下一個事務。

而它們的好處與壞處都是相對的。

先佔式多工、比較不會出現有特定事務霸佔執行權限、導致其它事務的進度無法推進的問題。舉例來説、非先佔式多工如果有單一個程序霸占了執行權限，那麽系統的其他的部分就會因爲沒有分配到 CPU 的時間而完全動彈不得。

但反過來看、協同式多工由於是各事務自行決定切換時機、所以可以選擇最佳的時機將事務移交出去。例如: 某個程序可以選擇、在進行要長時間等待的工作(e.g.: 等待建立網路連綫)時、把執行權限交出。這時候其它程序就可以有效的利用這段時間、不受打斷的進行工作。

# Multiprocessing vs Multithreading vs Coroutine

有了上面的切換概念、我們就可以來談談 multi-processing、multi-threading 和 coroutine 了。

||Multiprocessing|Multithreading|Coroutine|
|----|----|----|----|
|切換機制|先佔式|先佔式|協同式|
|切換管理|OS|OS|軟體自身|
|切換成本|較高|小|極小|
|事務間溝通成本|較高(需透過IPC)|低|低|
|使用多顆CPU|可|可|基本無法、需配合 multiprocess/multithread 輔助|
|適合場景(*1)|隔離性/容錯性要求高場景|一般多工場景|大量并發I/O|

注1:
* python 由於有著惡名昭彰的 GIL (Global Intepreter Lock)、同時間只能有 1 個 thread 執行 python code。這導致 python 無法透過 multithreading 來將工作分散到多顆 CPU 上
* 如果要利用多 CPU 進行平行處理、在 python 下必須使用 multiprocessing 的方式。而 multithreading 一般會傾向用於更偏 I/O bound 而非 CPU bound 的工作。